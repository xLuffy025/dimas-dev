*** a/experiments/bash/app-nota/notas.sh
--- b/experiments/bash/app-nota/notas.sh
*** replaced file contents (full replacement)
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# Directorios y archivos por defecto
DATA_DIR="${DATA_DIR:-$HOME/dimas-dev/nota}"
LOG_DIR="${LOG_DIR:-$DATA_DIR/logs}"
LOG_FILE="${LOG_FILE:-$LOG_DIR/notas.log}"
TRASH_DIR="$DATA_DIR/.trash"

mkdir -p "$DATA_DIR" "$LOG_DIR" "$TRASH_DIR"

# Inicializar variables usadas por el trap (evita errores con set -u)
current_command=''
last_command=''

# Registrar 칰ltimo comando para depuraci칩n
trap 'last_command=${current_command-}; current_command=$BASH_COMMAND' DEBUG
trap 'ret=$?; err "Fallo: comando \"${last_command:-unknown}\" devolvi칩 $ret"; exit $ret' ERR

# -------------------------------------------------------
#       Colores
# -------------------------------------------------------
GREEN="\e[32m"
YELLOW="\e[33m"
CYAN="\e[36m"
RED="\e[31m"
BLUE="\e[34m"
MAGENTA="\e[35m"
WHITE="\e[97m"
RESET="\e[0m"

# -------------------------------------------------------
#       Funciones de Mensajes 
# -------------------------------------------------------
msg(){ printf "%b==>%b %s\n" "$CYAN" "$RESET" "$1"; }
ok(){ printf "%b[九덢잺]  %b %s\n" "$GREEN" "$RESET" "$1"; }
warn(){ printf "%b[!]%b %s\n" "$YELLOW" "$RESET" "$1"; }
err(){ printf "%b[九뒲잺]  %b %s\n" "$RED" "$RESET" "$1"; } 

# -------------------------------------------------------
#   DEPENDENCIAS / EDITOR / GLOW
# -------------------------------------------------------
# Selecci칩n de editor: usa $EDITOR si est치 definido, si no busca nvim/vim/nano
choose_editor() {
  if [[ -n "${EDITOR-}" ]] && command -v "${EDITOR}" >/dev/null 2>&1; then
    printf '%s' "${EDITOR}"
    return
  fi
  for e in nvim vim nano; do
    if command -v "$e" >/dev/null 2>&1; then
      printf '%s' "$e"
      return
    fi
  done
  # Si no hay editor disponible, salimos con error
  err "No se encontr칩 un editor (neovim/vim/nano). Exporta \$EDITOR o instala uno."
  exit 1
}

EDITOR_CMD="$(choose_editor)"

if command -v glow >/dev/null 2>&1; then
  HAVE_GLOW=1
else
  HAVE_GLOW=0
  warn "glow no instalado; se usar치 'less' como fallback para ver notas."
fi

# --------------------------------------------------------
#   FUNCIONES GENERALES
# --------------------------------------------------------
# NOTAS: array global con rutas a archivos .md
obtener_notas() {
  shopt -s nullglob
  mapfile -t NOTAS < <(printf '%s\n' "$DATA_DIR"/*.md 2>/dev/null | sort -V)
  shopt -u nullglob
}

validar_notas() { 
  obtener_notas
  [[ ${#NOTAS[@]} -gt 0 ]] || return 1 
}

imprimir_notas() { 
  for i in "${!NOTAS[@]}"; do 
    nombre=$(basename "${NOTAS[$i]%.md}") 
    printf "%s) %s\n" "$((i+1))" "$nombre"
  done 
}

seleccionar_notas() {
  validar_notas || { err "No hay notas disponibles."; return 1; }

  msg "Notas disponibles:"
  imprimir_notas
  
  while true; do
    if ! read -r -p "Seleccione una nota por n칰mero (0 para cancelar): " opt; then
      return 1
    fi

    # Si el usuario ingres칩 0 -> cancelar, devolvemos 1 para que el caller lo propague
    cancelar_si_solicita "$opt" || return 1

    [[ "$opt" =~ ^[0-9]+$ ]] || { err "Ingresa un n칰mero v치lido."; pausa; continue; }

    idx=$((opt-1))
    if (( idx >= 0 && idx < ${#NOTAS[@]} )); then
      seleccion="${NOTAS[$idx]}"
      break
    else
      err "N칰mero fuera de rango."
      pausa
    fi
  done
}

pausa(){
  read -r -p "Presione Enter para continuar... " _ || true
}

log_info() {
  local mensaje="$1"
  printf '[INFO] %s - %s\n' "$(date '+%F %T')" "$mensaje" >> "$LOG_FILE" || \
    warn "No se pudo escribir en el log: $LOG_FILE"
}

cancelar_si_solicita() {
  local valor="$1"
  if [[ "$valor" == "0" ]]; then
    return 1
  fi 
  return 0
}

# --------------------------------------------------------
#         Funciones Principales
# --------------------------------------------------------
crear_nota() {
  while true; do 
    if ! read -r -p "Nombre de T칤tulo (0 para cancelar): " texto; then
      return 1
    fi 
    cancelar_si_solicita "$texto" || return 0

    # trim (quitar espacios al inicio/fin)
    texto="${texto#"${texto%%[![:space:]]*}"}"
    texto="${texto%"${texto##*[![:space:]]}"}"

    [[ -z "$texto"  ]] && {
      err "El t칤tulo no puede estar vac칤o."
      pausa
      continue
    }

    # Normalizar espacios a guiones bajos y eliminar caracteres no permitidos
    nota="${texto// /_}"

    # Validaci칩n: caracteres permitidos (letras, n칰meros, _ y -)
    if [[ ! "$nota" =~ ^[A-Za-z0-9_-]+$ ]]; then
      err "El t칤tulo solo permite letras, n칰meros, gui칩n bajo y gui칩n medio."
      pausa
      continue
    fi
  
    # Validaci칩n: existencia previa
    if [[ -f "$DATA_DIR/$nota.md" ]]; then
      err "Aviso: la nota ya existe. No se puede sobrescribir."
      pausa
      continue
    fi 

    break 
  done

  
  local FILENAME="$DATA_DIR/$nota.md"
  local TITLE="$texto"
  printf "# %s\n\n" "$TITLE" > "$FILENAME"
  log_info "Nota creada: $nota.md"

  "$EDITOR_CMD" "$FILENAME"
}

lista_notas() {
  clear
  validar_notas || { err "No hay notas disponibles."; return 1; }
  msg "Notas disponibles:"
  imprimir_notas
}

buscar_nota(){
  local palabra
  local resultados=()
  local idx opt seleccion_local

  if ! read -r -p "Ingresa palabra a buscar (0 para cancelar): " palabra; then
    return 1
  fi

  cancelar_si_solicita "$palabra" || return 0

  palabra="${palabra#"${palabra%%[![:space:]]*}"}"
  palabra="${palabra%"${palabra##*[![:space:]]}"}"

  [[ -z "$palabra" ]] && { err "Debes ingresar una palabra."; return 1; }
  
  obtener_notas
  validar_notas || { err "No hay notas disponibles."; return 1; }

  for archivo in "${NOTAS[@]}"; do 
    if grep -Fqi -- "$palabra" "$archivo"; then
      resultados+=("$archivo")
    fi 
  done

  if (( ${#resultados[@]} == 0 )); then
    warn "No se encontraron coincidencias."
    pausa 
    return 1 
  fi 

  echo
  msg "Coincidencias encontradas:"
  for i in "${!resultados[@]}"; do
    nombre=$(basename "${resultados[$i]%.md}")
    printf "%s) %s\n" "$((i+1))" "$nombre"
  done 

  while true; do
    if ! read -r -p "Seleccione una nota por n칰mero (0 para cancelar): " opt; then
      return 1
    fi

    cancelar_si_solicita "$opt" || return 0

    [[ "$opt" =~ ^[0-9]+$ ]] || { err "N칰mero inv치lido."; continue; }

    idx=$((opt-1))

    if (( idx >= 0 && idx < ${#resultados[@]} )); then 
      seleccion_local="${resultados[$idx]}"
      break 
    else 
      err "N칰mero fuera de rango."
    fi 
  done 

  clear
  msg "쯈u칠 desea hacer?"
  echo "1) Ver (preview) con glow/less"
  echo "2) Editar con $EDITOR_CMD"
  read -r -p "Elija una opci칩n: " opcion
  cancelar_si_solicita "$opcion" || return 0
  
  case $opcion in 
    1)
      # Mostrar l칤neas donde aparece la palabra y luego abrir con glow/less
      printf "\n%s\n\n" "$(grep -n --color=always -i -- "$palabra" "$seleccion_local" | sed -n '1,20p')"
      if (( HAVE_GLOW )); then
        glow "$seleccion_local"
      else
        less -R "$seleccion_local"
      fi
      ;;
    2) "$EDITOR_CMD" "$seleccion_local" ;;
    *) err "Opci칩n inv치lida." ;;
  esac 
}

editar_nota(){
  seleccionar_notas || return 1

  clear
  msg "쯈u칠 desea hacer con la nota?"
  echo "1) Ver con glow/less"
  echo "2) Editar con $EDITOR_CMD"
  read -r -p "Elige una opci칩n (1/2, 0 para cancelar): " opcion
  cancelar_si_solicita "$opcion" || return 0
  clear

  case $opcion in 
    1)
      if (( HAVE_GLOW )); then
        glow "$seleccion"
      else
        less -R "$seleccion"
      fi
      ;;
    2) "$EDITOR_CMD" "$seleccion" ;;
    *) err "Opci칩n inv치lida." ;;
  esac
}

eliminar_nota(){
  clear
  seleccionar_notas || return 1

  if [[ -f "$seleccion" ]]; then
    local nombre
    nombre=$(basename "$seleccion")
    read -r -p "쮼st치s seguro de que deseas eliminar '$nombre'? (s/n): " confirmacion
    if [[  "$confirmacion" == "s" || "$confirmacion" == "S" ]]; then 
      mkdir -p "$TRASH_DIR"
      mv "$seleccion" "$TRASH_DIR/" && {
        log_info "Nota movida a la papelera: $nombre"
        msg "El archivo '$nombre' ha sido movido a la papelera ($TRASH_DIR)."
      } || {
        err "No se pudo mover '$nombre' a la papelera."
      }
    else
      msg "La eliminaci칩n de '$nombre' ha sido cancelada."
    fi 
  else 
    msg "El archivo no existe."
  fi 
}

# --------------------------------------------------------
#         Men칰 Interactivo
# --------------------------------------------------------
mostrar_menu() {
  clear 
  printf "%b==============================%b\n" "$CYAN" "$RESET"
  printf "%b 游 Notas Markdown %b\n" "$CYAN" "$RESET"
  printf "%b==============================%b\n\n" "$CYAN" "$RESET"
  printf "%b1)%b Crear Nota\n" "$YELLOW" "$RESET"
  printf "%b2)%b Listar Notas\n" "$YELLOW" "$RESET"
  printf "%b3)%b Buscar por palabra\n" "$YELLOW" "$RESET"
  printf "%b4)%b Editar Nota\n" "$YELLOW" "$RESET"
  printf "%b5)%b Eliminar nota\n" "$YELLOW" "$RESET"
  printf "%b0)%b Salir\n\n" "$YELLOW" "$RESET"
}

# --------------------------------------------------------
#   FUNCIONES AUTOMATICAS / CLI
# --------------------------------------------------------
if [ $# -gt 0 ]; then
    case $1 in
        crear) crear_nota ;;
        listar) lista_notas ;;
        buscar) buscar_nota ;;
        editar) editar_nota ;;
        eliminar) eliminar_nota ;;
        *) err "Opci칩n no v치lida"; exit 1 ;;
    esac
else 
  while true; do
    mostrar_menu
    read -r -p "Seleccione una opci칩n: " opt 
    case $opt in
      1) crear_nota ;;
      2) lista_notas ;;
      3) buscar_nota ;;
      4) editar_nota ;;
      5) eliminar_nota ;;
      0) msg "Saliendo... "; exit 0 ;;
      *) err "Opci칩n no v치lida." ;;
    esac 
    pausa
  done
fi